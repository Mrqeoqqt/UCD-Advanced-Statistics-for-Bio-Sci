---
title: "STA-100 Handout 1 - Summary Statistics and Plots"
author: "Erin K. Melcon"
output: html_document
---
For this handout, will we be using a dataset that is already loaded into R.  For your homework, you will first have to upload the data, and include the command to do so in your code window.

The built in dataset is called `mtcars`.  To view the first few rows of a dataset, in general the command and you would type into the console would have the format:

`head(dataset)`

**Note, if you are copying from the .Rmd, and not the .html, you will need to remove the tick marks**

where instead of using `dataset` you would use the name of your dataset.  For example, mine is called `mtcars`, so the code I use is:

```{r}
head(mtcars)
```

The lines of code in between the ` ``` `{r} ` ``` ` and  are what you would type into the console and hit enter to see the result.  **You do not include the tick marks!**

To find the names of the columns in a dataset, you can use the function `names` in a similar way.  The general format would be:

`names(dataset)`

So for our example, the correct code for our dataset named cars would be

```{r}
names(mtcars)
```
## Summary Statistics for Numeric/Quantitative Random Variables
### 1.1 Finding the mean of a column
To find the mean of a column in R, you can use the function `mean`.  This function expects only a column in your dataset, not the entire dataset.  The general format is:

`mean(dataset$columnname)`

where instead of using `dataset` and `columnname` is the name of the particular column you want.  For example, if I wanted the mean of the column `mpg` in the dataset `mtcars`, I would use the following command:
```{r}
mean(mtcars$mpg)
```

### 1.1.1 Saving a result in R
Sometimes we do not want to print the result right away, but we want to save it and use it later.  For example, if I wanted to save the mean but not print it until I round it, I would do the following:

the.mean = mean(dataset$columnname)

This saves the result of `mean(dataset$columnname)` in the object `the.mean` in R.  It is like saving a file to your computer, except you are saving the result of a function to R.  The name `the.mean` is completely arbitrary, and could be anything you want, with a few exceptions. 

**The name cannot have a space in it, start with a number, or have most specical characters (such as &, %, etc).  Names are also case sensitive**

But, now I can save the mean of the mpg column as follows:

```{r}
the.mean = mean(mtcars$mpg)
```
**When you put this command in your console and press enter, you will not see the result.   This is ok!! It means the result has been saved, and I can now use it for other things.  If I want to see the result, I can type the.mean in the console to see what the mean was.**

```{r}
the.mean
```

### 1.2 Finding the standard deviation of a column
To find the standard deviation of a column, the format is very similar to that of using the function `mean`.  The general format is:

`sd(dataset$columnname)`

Where dataset is the name of your dataset, and columnnname is the name of the column of which you want to find the standard deviation of.  For example, if I wanted the standard deviation of the mpg column rounded to three decimal places, I would use the following commands

```{r}
the.sd = sd(mtcars$mpg)
round(the.sd,3)
```

### 1.3 Finding the median of a column
Again, the format is very similar to what we have seen, but instead we use the function `median`:

`median(dataset$columnname)`

For example. the median of the column `mpg` is:
```{r}
the.median = median(mtcars$mpg)
the.median
```

### 1.3 Finding the "five number summary" of a column
The five number summary of a column consists of: the minimum, the first quartile, the median, the third quartile, and the maximum.  There is a function that does this in R called `fivenum`, which we use in the same way as above:

`fivenum(dataset$columnname)`

For example, the five number summary of the mpg column is:

```{r} 
fivenum(mtcars$mpg)
```

### 2.1 Finding the mean of a column by groups.
To find the mean of a column for every group, you need two columns - one should be a column with numeric values, and one should be a column with labels.  Then, the general format is

`aggregate(numericcolumn ~ groupcolumn, data = dataset, mean)`

Where you would put the name of your numeric column (the column that holds numbers) instead of `numericcolumn`, and the name of your grouping column (the column that holds groups or labels) instead of `groupcolumn`, and replace the name of `dataset`.  

For example, if I wanted to find the average mpg per number of gears, I would use the following:

```{r}
aggregate(mpg ~ gear, data = mtcars, mean)
```
**Note that R goes by alphabetical order if your group names are words**.


### 2.1.1 Accessing the results of aggregate
We have already learned how to use the function `aggregate` above, but notice that the object returned had two columns.  If we want to access just one of the columns, we can use the $ operator in R.  First, I will save the result of aggregate as something, then access just the columns with the means.

```{r}
many.means = aggregate(mpg ~ gear, data = mtcars, mean)
many.means$mpg
```
This gives a list of all of the means of all of the groups.  To see which order they were in, I could look at the column called (in my case) gear:
```{r}
names(many.means)
many.means$gear
```
Now I know that the value 16.10667 corresponds to the group 3. 

### 2.2 Finding other summary statistics by group
The function `aggregate` is actually very broad, and we do not have to use it to find only the mean.  Any of the functions above (`sd`,`median`) can be used with aggregate as well.  In general, any function which returns one number can be used with aggregate.

`aggregate(numericcolumn ~ groupcolumn, data = dataset, functionname)`

Where `functionname` is replaced by whatever function we want, for example `sd` or `median`.  Thus, if we want to find the standard deviation of mpg per number of gears, we would use:

```{r}
aggregate(mpg ~ gear, data = mtcars, sd)
```

For the median per group we would use: 

```{r}
aggregate(mpg ~ gear, data = mtcars, median)
```


### 2.3 The number of subjects in a group
To find the number of subjects per group, we can again use the function aggregate.  The general format is: 

`aggregate( numericname ~ groupname, data = dataset, length)`

Where you would put the name of your numeric column instead of `numeric name`, and the name of your grouping column instead of `groupname`, and replace the name of `dataset`.  Using this on our mpg column gives:

```{r}
aggregate(mpg ~ gear, data = mtcars, length)
```

## Summary Statistics for categorical varaiables
For categorical variables, we usually just want to make a table of counts (frequencies), or a table of probabilities.
### 3.1 Table of counts - one categorical variable
There is a function in R called `table`, which makes a frequency table of the column you give it.  The general format is:

`table(dataset$categoricalcolumn)`

Where you would replace `dataset` with your dataset name, and `categoricalcolumn` with your name of the column that has groups.  I'm going to assume that the column `gear` in my dataset is what I want to group by.  The table of how many subjects are in each group is then:
```{r}
table(mtcars$gear)
```
That tells me that 15 had 3 gears, 12 had 4, and 5 had 5.

To get a table of probabilities, or relative frequencies, I would want to divide the numbers in the table by the number of subjects total.  An easy way to do this is:

`table(dataset$categoricalcolumn)/sum(table(dataset$categoricalcolumn))`

The function `sum` adds all the things in a list of numbers.   Thus, the relative frequency of each gear category is:
```{r} 
table(mtcars$gear)/sum(table(mtcars$gear))
```

### 3.2 Table of counts - two categorical variables.
When we have two categorical variables, we can make a two-way table, and a two-way table of probabilities.  To make a two way table (and save it), we need to know the names of two columns that have categorical variables. Then, the two-way table general format is:

`table(dataset$categoricalcolumn1, dataset$categoricalcolumn2)`

For my example, I will assume `gear` is one column, and `am` is the other one.  

```{r}
two.way = table(mtcars$gear,mtcars$am)
two.way
```

To get the probabilities, I could still use the same command as above, but modifying it so that it uses the two-way table that I have saved.

```{r}
two.way/sum(two.way)
```

## Plotting things in R
When we get data, the first thing we should do is plot it!  Why?  Because that gives us ideas about the distribution of the data, and how the variables relate to each other, which will give us an idea about what we may want to test. 

I will use two different plotting methods - one using simple functions in R, and another using a more complex function.  One plot is basically prettier, but is more difficult to use in R. 

### 4.1 - Plots for a single numeric random variable
### 4.1.1 Histograms 
To plot a histogram, there is a function called `hist`.  The general format is:

`hist(datatset$numericcolumn, main = "The title for the graph",xlab = "the label for the x-axis",ylab = "The label for the y axis")`

You would have to replace `dataset`, `numericcolumn`, and the titles (leave the quotes, change the words).  Often, you do not have to change the y axis, so you could remove that part completely.  For example, 
```{r}
hist(mtcars$mpg,main = "Distribution of MPG",xlab = "Miles Per Gallon")
```

Now, some people think that the above plot is pretty ugly.  We can make a nicer one, using a built in package from `ggplot2`.  First, we have to **load the package**. The package was installed when R was installed, but it is not present by default (we cannot use the functions in the package by default).  To load the package, use the command `library(ggplot2)`:
```{r}
library(ggplot2)
```
Now, the format for making a histogram (looks VERY different!) is:

`ggplot(dataset, aes(x = numericcolumn)) + geom_histogram(binwidth = somenumber)`

What you would change is still `dataset`, and `numeric column`, and additionally `somenumber`.  `somenumber` is the width you want your bins to be.  Say I wanted a histogram with bin width 2 mpg:

```{r}
ggplot(mtcars, aes(x = mpg)) + geom_histogram(binwidth = 2)
```
The nice thing about this function is I can customize it.  Say I wanted to make the outline of the bins black, and the inside white:
```{r}
ggplot(mtcars, aes(x = mpg)) + geom_histogram(binwidth = 2,color = "black",fill = "white")
```
Looks nicer!  But ultimately it gives the same information as the not-so-pretty histogram.

### 4.1.2 Boxplots
Boxplots can be made with the simple R function, or using ggplot2 as well.  For the simple function the general format is:

`boxplot(dataset$numericcolumn, main = "The main title",horizontal = TRUE, xlab = "The X axis label")`

For the fancier one using ggplot2:

`ggplot(dataset, aes(y=numericcolumn, x = factor("")) + geom_boxplot() + coord_flip() + ylab("Title for the x-axis") + xlab("") +ggtitle("Main Title")`

Again, you would change `dataset`, `numericcolumn`, and the titles (but leave the quotation marks)
For example, using mpg:
```{r}
boxplot(mtcars$mpg, main = "Distribution of MPG",xlab = "Miles Per Gallon",horizontal = TRUE)
ggplot(mtcars, aes(y=mpg, x = factor("")))+ geom_boxplot() + ylab("Miles Per Gallon") + xlab(" ")+ coord_flip() + ggtitle("Distribution of Miles per Gallon")
```

### 4.2 - Plots for a single categorical random variable
### 4.2.1 Barplot
Again, there are two functions we can use.  For the generic function, the command would look like:

`my.table = table(dataset$categoricalcolumn)`
`barplot(my.table, main = "The main title")`

Notice for this function, we have to make the table first, then plot the table.  For the ggplot2 function:

`ggplot(dataset,aes(x = categoricalcolumn)) + geom_bar()+ ggtitle("The main title")`

Using gears as my categorical data:

```{r}
gear.table = table(mtcars$gear)
barplot(gear.table,main = "Number of gears")
ggplot(mtcars, aes(x = gear)) + geom_bar()+ ggtitle("Number of gears")
```

### 4.3 Plots for two numeric random variables
### 4.3.1 Scatter plot
For two numeric variables, we often want to plot variable vs. another.  For this we need to know the names of two columns which hold numeric variables.  Then, the format is:

`plot(dataset$numericcolumnX, dataset$numericcolumnY,main  = "Main Title",xlab="Title for X-axis",ylab = "Title for y-axis",pch = 19)`

mostly it is the same format as we have seen, but the command `pch` stands for "plotting character" (should it plot circles, triangles, etc).  For that you can use any number from 1 to 20. 

For the ggplot version, the format is:

`qplot(numericcolumnX, numericcolumnY, data = dataset) + ggtitle("Main title") + xlab("Title for the x-axis") + ylab("Title for the y-axis")`

For example, lets look at how the column `wt` and the column `mpg` are plotted against each other:

```{r} 
plot(mtcars$wt,mtcars$mpg, main = "Weight vs. MPG",xlab = "Weight of Car",ylab = "Miles Per Gallon", pch = 19)
```

Using ggplot2:
```{r} 
qplot(wt, mpg, data = mtcars) +  ggtitle("Weight vs. MPG") + xlab("Weight of Car") + ylab("Miles Per Gallon")
```

### 4.4 Plots for two categorical random variables
For two categorical variables, there are two popular choices of plots.
### 4.4.1 Barplot
To make a barplot, we need a 2-way table.  As a reminder, the general command is:

`two.way = table(dataset$categoricalcolumn1, dataset$categoricalcolumn2)`

Then, we can use the function `barplot` again on the two-way table.  The general format is:

`barplot(two.way, beside = TRUE, legend.text = rownames(two.way),main = "main title")`

The command `beside = TRUE` says to make the bars beside each other, rather than on top of each other.  The command `legend.text` gives the legend for the bar plots.

Lets say I want to look at the columns `am` and `gear`:

```{r} 
two.way = table(mtcars$am, mtcars$gear)
barplot(two.way, beside = TRUE, legend.text =  rownames(two.way), main = "Gear vs AM")
```

the command `beside = TRUE` says to make the bars beside each other, rather than on top of each other.  The command `legend.text` gives the legend for the bar plots.

The order in which I give columns to make my table matters.  For example, if I switch the order:

```{r}
two.way = table(mtcars$gear, mtcars$am)
barplot(two.way, beside = TRUE, legend.text =  rownames(two.way))
```

In ggplot2, we may sometimes have to make the columns `factors` in R, which tells R to treat the column as if it were a grouping variable (if they are not already).  Here, I have to do that, because my "group" columns are actually numbers.  To make a column a "factor" in R: 

`dataset$cateogricalcolumn = as.factor(dataset$categoricalcolumn)`

So to make my columns am and gear factors:

```{r}
mtcars$am = as.factor(mtcars$am)
mtcars$gear = as.factor(mtcars$gear)
```

Then, the general format for the ggplot is:

`ggplot(dataset, aes(x = categoricalcolumn1, fill = categoricalcolumn2)) + geom_bar(position ="dodge")`

Again, the order matters.  To view the two different plots:
```{r}
ggplot(mtcars, aes(x = gear, fill = am)) + geom_bar(position = "dodge")
ggplot(mtcars, aes(x = am, fill = gear)) + geom_bar(position = "dodge")
```

### 4.4.2 Mosaic plot
A mosaic plot is useful because it shows relative proportions of each categorical variable by group of the other categorical variable.  To create the plots using the default packages is easy enough.  You create a two-way table, and then the format is:

`mosaicplot(two.way,main = "main title")`

Again, ordering matters.  For example, one ordering gives:
```{r}
two.way = table(mtcars$am,mtcars$gear)
mosaicplot(two.way, main = "Gear vs AM")
```

This shows that out of all the am 0 cars, most have 3 gears, some have 4, and none have 5.  Out of all the am 1 cars, none have 3 gears, most have 4 gears, and some have 5.  

There is no easy way to do a mosaic plot using ggplot2, sadly.

### 4.5 Plots for one categorical and one numeric random variable
There are two common (and useful) plots for a numerical variable based on a categorical variable.
### 4.5.1 Boxplot by group
To make a boxplot by group, the general format is:

`boxplot(numericcolumn ~ categoricalcolumn, data = dataset, main = "Main title",horizontal = TRUE)`

For example, if we wanted to view mpg by gear:

```{r}
boxplot(mpg ~ gear, data = mtcars, main = "Milage by Gear", horizontal = TRUE)
```

In ggplot2, the general format is:

`ggplot(dataset, aes(y=numericcolumn, x = categoricalcolumn))+ geom_boxplot() + ylab("Title for X-axis")+ xlab("Title for y-axis") + ggtitle("Main title") + coord_flip()` 

For example:
```{r}
ggplot(mtcars,aes(y = mpg,x =gear)) + geom_boxplot() + ylab("Miles per Gallon") + xlab("Number of Gears") + ggtitle("MPG by gear") + coord_flip() 
```


### 4.5.1 Histogram by group
There is no default function to make a histrogram by group, but there is one in ggplot2.  The general format is:

`ggplot(dataset, aes(x = numericcolumn)) + geom_histogram(binwidth = 2) + facet_grid(categoricalcolumn ~.) +ggtitle("Main title")`

This will make stacked plots.  If we want both histograms on the same plot:

`ggplot(dataset, aes(x=nmericcolumn, fill=categoricalcolumn)) + geom_histogram(binwidth=.5, alpha=.5, position="identity") + ggtitle("Main Title")`

To see the differences:

```{r}
ggplot(mtcars, aes(x = mpg)) + geom_histogram(binwidth = 2,,color = "black",fill = "white") + facet_grid(gear ~.) +ggtitle("MPG by number of gears")

ggplot(mtcars, aes(x=mpg, fill=gear)) + geom_histogram(binwidth=2, alpha=.5, position="identity") + ggtitle("MPG by number of gears")
```

For this particular data, one certainly looks nicer than the other.  But it depends on your dataset.

## Summary of handout 1
This should be all the commands you need for your first homework assignment.  As a summary, we have learned about the following functions:

mean, sd, aggregate, round, fivenum, head, names, aggregate

barplot, boxplot, hist, mosaicplot  (and all the ggplot alternatives)

and how to access columns of a dataset using the $ operator and the column name.

**For your homework, you should only have to replace column names and the dataset name - everything else will be very similar to the above commands.**